// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List               = require("bs-platform/lib/js/list.js");
var $$Array            = require("bs-platform/lib/js/array.js");
var Caml_array         = require("bs-platform/lib/js/caml_array.js");
var Caml_int32         = require("bs-platform/lib/js/caml_int32.js");
var Pervasives         = require("bs-platform/lib/js/pervasives.js");
var Caml_format        = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode = require("./Utils.bs.js");

function logList(node) {
  console.log($$Array.of_list(node));
  return /* () */0;
}

function parseOps(str) {
  return List.map(Caml_format.caml_int_of_string, Utils$AdventOfCode.splitString(",", str));
}

function rotateLeft(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n !== 0) {
      _xs = Pervasives.$at(List.tl(xs), /* :: */[
            List.hd(xs),
            /* [] */0
          ]);
      _n = n - 1 | 0;
      continue ;
      
    } else {
      return xs;
    }
  };
}

function reverseSlice(nums, start, len) {
  var length = nums.length;
  for(var i = 0 ,i_finish = (len / 2 | 0) - 1 | 0; i <= i_finish; ++i){
    var j = Caml_int32.mod_(start + i | 0, length);
    var k = Caml_int32.mod_(((start + len | 0) - 1 | 0) - i | 0, length);
    var tmp = Caml_array.caml_array_get(nums, k);
    Caml_array.caml_array_set(nums, k, Caml_array.caml_array_get(nums, j));
    Caml_array.caml_array_set(nums, j, tmp);
  }
  return /* () */0;
}

function performOp(param, op) {
  var skipLength = param[2];
  var currPos = param[1];
  var nums = param[0];
  reverseSlice(nums, currPos, op);
  return /* tuple */[
          nums,
          Caml_int32.mod_((currPos + op | 0) + skipLength | 0, nums.length),
          skipLength + 1 | 0
        ];
}

function performOps(state, ops) {
  return List.fold_left(performOp, state, ops);
}

function makeArray(n) {
  return $$Array.init(n, (function (n) {
                return n;
              }));
}

function runProg(str) {
  var ops = parseOps(str);
  var state_000 = $$Array.init(256, (function (n) {
          return n;
        }));
  var state = /* tuple */[
    state_000,
    0,
    0
  ];
  return List.fold_left(performOp, state, ops);
}

function toAsciiCodes(str) {
  return List.map((function (prim) {
                return prim;
              }), Utils$AdventOfCode.charsOfString(str));
}

var inputSuffix = /* :: */[
  17,
  /* :: */[
    31,
    /* :: */[
      73,
      /* :: */[
        47,
        /* :: */[
          23,
          /* [] */0
        ]
      ]
    ]
  ]
];

function toHex(i) {
  var s = i.toString(16);
  var match = +(s.length === 1);
  if (match !== 0) {
    return "0" + s;
  } else {
    return s;
  }
}

function hash(input) {
  var input$1 = Pervasives.$at(List.map((function (prim) {
              return prim;
            }), Utils$AdventOfCode.charsOfString(input)), inputSuffix);
  var match = List.fold_left((function (state, _) {
          return List.fold_left(performOp, state, input$1);
        }), /* tuple */[
        $$Array.init(256, (function (n) {
                return n;
              })),
        0,
        0
      ], Utils$AdventOfCode.range(63));
  var sparseHash = match[0];
  var denseHash = Caml_array.caml_make_vect(16, 0);
  for(var i = 0; i <= 255; ++i){
    var j = i / 16 | 0;
    Caml_array.caml_array_set(denseHash, j, Caml_array.caml_array_get(denseHash, j) ^ Caml_array.caml_array_get(sparseHash, i));
  }
  return $$Array.fold_left((function (str, i) {
                return str + toHex(i);
              }), "", denseHash);
}

exports.logList      = logList;
exports.parseOps     = parseOps;
exports.rotateLeft   = rotateLeft;
exports.reverseSlice = reverseSlice;
exports.performOp    = performOp;
exports.performOps   = performOps;
exports.makeArray    = makeArray;
exports.runProg      = runProg;
exports.toAsciiCodes = toAsciiCodes;
exports.inputSuffix  = inputSuffix;
exports.toHex        = toHex;
exports.hash         = hash;
/* No side effect */
