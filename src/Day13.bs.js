// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode      = require("./Utils.bs.js");
var Inputs$AdventOfCode     = require("./Inputs.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function parseFirewall(str) {
  return $$Array.map((function (line) {
                var param = Utils$AdventOfCode.splitString(": ", line);
                var exit = 0;
                if (param) {
                  var match = param[1];
                  if (match) {
                    if (match[1]) {
                      exit = 1;
                    } else {
                      return /* tuple */[
                              Caml_format.caml_int_of_string(param[0]),
                              Caml_format.caml_int_of_string(match[0])
                            ];
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                if (exit === 1) {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        [
                          "/Users/bjorn/projects/advent-of-code/src/Day13.re",
                          15,
                          9
                        ]
                      ];
                }
                
              }), $$Array.of_list(Utils$AdventOfCode.linesOfString(str)));
}

function makeFirewall(scanners) {
  var numLayers = 1 + Caml_array.caml_array_get(scanners, scanners.length - 1 | 0)[0] | 0;
  var firewall = Caml_array.caml_make_vect(numLayers, /* None */0);
  $$Array.iter((function (param) {
          return Caml_array.caml_array_set(firewall, param[0], /* Some */[/* record */[
                        /* position */0,
                        /* direction : Down */1,
                        /* depth */param[1]
                      ]]);
        }), scanners);
  return firewall;
}

function moveScanner(layer) {
  if (layer) {
    var scanner = layer[0];
    var depth = scanner[/* depth */2];
    var direction = scanner[/* direction */1];
    var position = scanner[/* position */0];
    var tmp;
    if (position === 0 && direction === /* Up */0) {
      tmp = /* record */[
        /* position */1,
        /* direction : Down */1,
        /* depth */scanner[/* depth */2]
      ];
    } else if (position === (depth - 1 | 0) && direction === /* Down */1) {
      tmp = /* record */[
        /* position */depth - 2 | 0,
        /* direction : Up */0,
        /* depth */scanner[/* depth */2]
      ];
    } else {
      var match = +(direction === /* Up */0);
      tmp = /* record */[
        /* position */match !== 0 ? position - 1 | 0 : position + 1 | 0,
        /* direction */scanner[/* direction */1],
        /* depth */scanner[/* depth */2]
      ];
    }
    return /* Some */[tmp];
  } else {
    return layer;
  }
}

function calcSeverity(packetPosition, layers) {
  var match = Caml_array.caml_array_get(layers, packetPosition);
  if (match) {
    var match$1 = match[0];
    if (match$1[/* position */0]) {
      return /* None */0;
    } else {
      return /* Some */[/* tuple */[
                packetPosition,
                Caml_int32.imul(match$1[/* depth */2], packetPosition)
              ]];
    }
  } else {
    return /* None */0;
  }
}

function delayFirewall(firewall) {
  return $$Array.map(moveScanner, firewall);
}

function crossFirewall($staropt$star, firewall) {
  var breakWhenCaught = $staropt$star ? $staropt$star[0] : /* false */0;
  var _packetPosition = 0;
  var _firewall = firewall;
  var _severities = /* [] */0;
  while(true) {
    var severities = _severities;
    var firewall$1 = _firewall;
    var packetPosition = _packetPosition;
    var severity = calcSeverity(packetPosition, firewall$1);
    var severities$1 = severity ? /* :: */[
        severity[0],
        severities
      ] : severities;
    if (packetPosition === (firewall$1.length - 1 | 0)) {
      return severities$1;
    } else if (breakWhenCaught && severity !== /* None */0) {
      return severities$1;
    } else {
      _severities = severities$1;
      _firewall = $$Array.map(moveScanner, firewall$1);
      _packetPosition = packetPosition + 1 | 0;
      continue ;
      
    }
  };
}

var firewallDef = parseFirewall(Inputs$AdventOfCode.day13);

var firewall = makeFirewall(firewallDef);

var previousFirewall = [firewall];

function findPerfectDelay(_currentDelay) {
  while(true) {
    var currentDelay = _currentDelay;
    var currentFirewall = $$Array.map(moveScanner, previousFirewall[0]);
    previousFirewall[0] = currentFirewall;
    var match = +(List.length(crossFirewall(/* Some */[/* true */1], currentFirewall)) === 0);
    if (match !== 0) {
      return currentDelay;
    } else {
      _currentDelay = currentDelay + 1 | 0;
      continue ;
      
    }
  };
}

console.log(findPerfectDelay(1));

exports.parseFirewall = parseFirewall;
exports.makeFirewall  = makeFirewall;
exports.moveScanner   = moveScanner;
exports.calcSeverity  = calcSeverity;
exports.delayFirewall = delayFirewall;
exports.crossFirewall = crossFirewall;
/* firewallDef Not a pure module */
