// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function step(_node, _steps) {
  while(true) {
    var steps = _steps;
    var node = _node;
    var match = +(steps === 0);
    if (match !== 0) {
      return node;
    } else {
      _steps = steps - 1 | 0;
      _node = node[/* next */1][0];
      continue ;
      
    }
  };
}

function insertAfter(node, value) {
  var next = node[/* next */1][0];
  node[/* next */1][0] = /* record */[
    /* value */value,
    /* next */[next]
  ];
  return node[/* next */1][0];
}

function spinlock(_node, stepsPerInsert, _nextValue, insertUntil) {
  while(true) {
    var nextValue = _nextValue;
    var node = _node;
    if (nextValue > insertUntil) {
      return node[/* next */1][0][/* value */0];
    } else {
      var currentNode = step(node, stepsPerInsert);
      _nextValue = nextValue + 1 | 0;
      _node = insertAfter(currentNode, nextValue);
      continue ;
      
    }
  };
}

var startNode = [];

Caml_obj.caml_update_dummy(startNode, /* record */[
      /* value */0,
      /* next */[startNode]
    ]);

console.log(spinlock(startNode, 337, 1, 2017));

function part2(_afterZero, _position, _next) {
  while(true) {
    var next = _next;
    var position = _position;
    var afterZero = _afterZero;
    if (next > 50000000) {
      return afterZero;
    } else {
      var nextPosition = Caml_int32.mod_(position + 337 | 0, next);
      var match = +(nextPosition === 0);
      _next = next + 1 | 0;
      _position = nextPosition + 1 | 0;
      _afterZero = match !== 0 ? next : afterZero;
      continue ;
      
    }
  };
}

console.log(part2(0, 0, 1));

exports.step        = step;
exports.insertAfter = insertAfter;
exports.spinlock    = spinlock;
/*  Not a pure module */
