// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Int64                   = require("bs-platform/lib/js/int64.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var Hashtbl                 = require("bs-platform/lib/js/hashtbl.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int64              = require("bs-platform/lib/js/caml_int64.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Utils$AdventOfCode      = require("./Utils.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function parseRegister(str) {
  return Caml_string.get(str, 0);
}

function parseRegisterOrValue(str) {
  try {
    return /* Value */Block.__(1, [Caml_format.caml_int_of_string(str)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* Register */Block.__(0, [Caml_string.get(str, 0)]);
    } else {
      throw exn;
    }
  }
}

function parseInstruction(str) {
  var match = Utils$AdventOfCode.splitString(" ", str);
  if (match) {
    var params = match[1];
    var ins = match[0];
    switch (ins) {
      case "add" : 
          return /* Add */Block.__(2, [
                    Caml_string.get(List.nth(params, 0), 0),
                    parseRegisterOrValue(List.nth(params, 1))
                  ]);
      case "jgz" : 
          return /* Jgz */Block.__(6, [
                    Caml_string.get(List.nth(params, 0), 0),
                    parseRegisterOrValue(List.nth(params, 1))
                  ]);
      case "mod" : 
          return /* Mod */Block.__(4, [
                    Caml_string.get(List.nth(params, 0), 0),
                    parseRegisterOrValue(List.nth(params, 1))
                  ]);
      case "mul" : 
          return /* Mul */Block.__(3, [
                    Caml_string.get(List.nth(params, 0), 0),
                    parseRegisterOrValue(List.nth(params, 1))
                  ]);
      case "rcv" : 
          return /* Rcv */Block.__(5, [Caml_string.get(List.nth(params, 0), 0)]);
      case "set" : 
          return /* Set */Block.__(1, [
                    Caml_string.get(List.nth(params, 0), 0),
                    parseRegisterOrValue(List.nth(params, 1))
                  ]);
      case "snd" : 
          return /* Snd */Block.__(0, [parseRegisterOrValue(List.nth(params, 0))]);
      default:
        return Pervasives.failwith("Unrecognized instruction: " + ins);
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/bjorn/projects/advent-of-code/src/Day18.re",
            28,
            6
          ]
        ];
  }
}

function parseProgram(input) {
  return $$Array.of_list(List.map(parseInstruction, Utils$AdventOfCode.linesOfString(input)));
}

var input = Curry._1(Utils$AdventOfCode.loadInput, "day18");

var prog = parseProgram(input);

var progLen = prog.length;

var mem = Hashtbl.create(/* None */0, 15);

function readReg(r) {
  try {
    return Hashtbl.find(mem, r);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Int64.zero;
    } else {
      throw exn;
    }
  }
}

function resolveRegOrVal(regOrVal) {
  if (regOrVal.tag) {
    return Caml_int64.of_int32(regOrVal[0]);
  } else {
    return readReg(regOrVal[0]);
  }
}

function runProg(_insPtr, _lastSound, _recoveredFrequencies) {
  while(true) {
    var recoveredFrequencies = _recoveredFrequencies;
    var lastSound = _lastSound;
    var insPtr = _insPtr;
    if (insPtr < 0 || insPtr >= progLen) {
      console.log("Done!");
      return /* () */0;
    } else {
      var match = Caml_array.caml_array_get(prog, insPtr);
      switch (match.tag | 0) {
        case 0 : 
            _lastSound = resolveRegOrVal(match[0]);
            _insPtr = insPtr + 1 | 0;
            continue ;
            case 1 : 
            var param = resolveRegOrVal(match[1]);
            Hashtbl.replace(mem, match[0], param);
            _insPtr = insPtr + 1 | 0;
            continue ;
            case 2 : 
            var r = match[0];
            var param$1 = Caml_int64.add(readReg(r), resolveRegOrVal(match[1]));
            Hashtbl.replace(mem, r, param$1);
            _insPtr = insPtr + 1 | 0;
            continue ;
            case 3 : 
            var r$1 = match[0];
            var param$2 = Caml_int64.mul(readReg(r$1), resolveRegOrVal(match[1]));
            Hashtbl.replace(mem, r$1, param$2);
            _insPtr = insPtr + 1 | 0;
            continue ;
            case 4 : 
            var r$2 = match[0];
            var param$3 = Utils$AdventOfCode.mod64(readReg(r$2), resolveRegOrVal(match[1]));
            Hashtbl.replace(mem, r$2, param$3);
            _insPtr = insPtr + 1 | 0;
            continue ;
            case 5 : 
            var r$3 = match[0];
            if (Caml_int64.gt(readReg(r$3), Int64.zero)) {
              Hashtbl.replace(mem, r$3, lastSound);
              console.log(lastSound);
              _recoveredFrequencies = /* :: */[
                lastSound,
                recoveredFrequencies
              ];
              _insPtr = insPtr + 1 | 0;
              continue ;
              
            } else {
              _insPtr = insPtr + 1 | 0;
              continue ;
              
            }
            break;
        case 6 : 
            if (Caml_int64.gt(readReg(match[0]), Int64.zero)) {
              _insPtr = insPtr + (resolveRegOrVal(match[1])[1] | 0) | 0;
              continue ;
              
            } else {
              _insPtr = insPtr + 1 | 0;
              continue ;
              
            }
            break;
        
      }
    }
  };
}

runProg(0, Int64.zero, /* [] */0);

exports.parseRegister        = parseRegister;
exports.parseRegisterOrValue = parseRegisterOrValue;
exports.parseInstruction     = parseInstruction;
exports.parseProgram         = parseProgram;
/* input Not a pure module */
