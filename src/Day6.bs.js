// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                = require("bs-platform/lib/js/list.js");
var $$Array             = require("bs-platform/lib/js/array.js");
var Hashtbl             = require("bs-platform/lib/js/hashtbl.js");
var Caml_array          = require("bs-platform/lib/js/caml_array.js");
var Caml_int32          = require("bs-platform/lib/js/caml_int32.js");
var Caml_format         = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode  = require("./Utils.bs.js");
var Inputs$AdventOfCode = require("./Inputs.bs.js");

function nextBlockForRedistribution(memory) {
  return List.fold_left2((function (param, index, blockCount) {
                  var nextBlockCount = param[1];
                  var match = +(blockCount > nextBlockCount);
                  if (match !== 0) {
                    return /* tuple */[
                            index,
                            blockCount
                          ];
                  } else {
                    return /* tuple */[
                            param[0],
                            nextBlockCount
                          ];
                  }
                }), /* tuple */[
                0,
                Caml_array.caml_array_get(memory, 0)
              ], Utils$AdventOfCode.range(memory.length - 1 | 0), $$Array.to_list(memory))[0];
}

function redistributeBlock(memory, blockIndex) {
  var memLength = memory.length;
  var blocksToRedistribute = Caml_array.caml_array_get(memory, blockIndex);
  Caml_array.caml_array_set(memory, blockIndex, 0);
  var redistributeBlocks = function (_blocksLeft, _currentBlockIndex) {
    while(true) {
      var currentBlockIndex = _currentBlockIndex;
      var blocksLeft = _blocksLeft;
      if (blocksLeft > 0) {
        Caml_array.caml_array_set(memory, currentBlockIndex, Caml_array.caml_array_get(memory, currentBlockIndex) + 1 | 0);
        _currentBlockIndex = Caml_int32.mod_(currentBlockIndex + 1 | 0, memLength);
        _blocksLeft = blocksLeft - 1 | 0;
        continue ;
        
      } else {
        return 0;
      }
    };
  };
  redistributeBlocks(blocksToRedistribute, Caml_int32.mod_(blockIndex + 1 | 0, memory.length));
  return /* () */0;
}

function redistributeMemory(memory) {
  return redistributeBlock(memory, nextBlockForRedistribution(memory));
}

function redistributeUntilCycle(memory) {
  var memoryHistory = Hashtbl.create(/* None */0, 100);
  var redistributions = 0;
  while(!Hashtbl.mem(memoryHistory, $$Array.to_list(memory))) {
    Hashtbl.add(memoryHistory, $$Array.to_list(memory), redistributions);
    redistributeBlock(memory, nextBlockForRedistribution(memory));
    redistributions = redistributions + 1 | 0;
  };
  return redistributions - Hashtbl.find(memoryHistory, $$Array.to_list(memory)) | 0;
}

console.log(redistributeUntilCycle($$Array.of_list(List.map(Caml_format.caml_int_of_string, Utils$AdventOfCode.splitString("\t", Inputs$AdventOfCode.day6)))));

exports.nextBlockForRedistribution = nextBlockForRedistribution;
exports.redistributeBlock          = redistributeBlock;
exports.redistributeMemory         = redistributeMemory;
exports.redistributeUntilCycle     = redistributeUntilCycle;
/*  Not a pure module */
