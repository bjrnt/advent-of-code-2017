// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var Hashtbl                 = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_format             = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode      = require("./Utils.bs.js");
var Inputs$AdventOfCode     = require("./Inputs.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function getParent(tower) {
  return tower[/* parent */4];
}

function decodeTowerInfo(info) {
  var name = List.hd(Utils$AdventOfCode.splitString(" ", info));
  var weight = Caml_format.caml_int_of_string(List.hd(List.tl(Utils$AdventOfCode.splitString("(", List.hd(Utils$AdventOfCode.splitString(")", info))))));
  var match = Utils$AdventOfCode.splitString(" -> ", info);
  var descendants;
  if (match) {
    var match$1 = match[1];
    descendants = match$1 && !match$1[1] ? Utils$AdventOfCode.splitString(", ", match$1[0]) : /* [] */0;
  } else {
    descendants = /* [] */0;
  }
  return /* record */[
          /* name */name,
          /* weight */weight,
          /* cumulativeWeight : None */0,
          /* descendants */descendants,
          /* parent : None */0
        ];
}

function decodeTowerInfos(lines) {
  return List.map(decodeTowerInfo, Utils$AdventOfCode.linesOfString(lines));
}

var graph = Hashtbl.create(/* None */0, 100);

function addNode(node) {
  return Hashtbl.add(graph, node[/* name */0], node);
}

function replaceNode(node) {
  return Hashtbl.replace(graph, node[/* name */0], node);
}

function findNode(name) {
  return Hashtbl.find(graph, name);
}

function makeGraph(towerInfos) {
  List.iter(addNode, towerInfos);
  return List.iter((function (param) {
                var name = param[/* name */0];
                return List.iter((function (descendant) {
                              var init = Hashtbl.find(graph, descendant);
                              return replaceNode(/* record */[
                                          /* name */init[/* name */0],
                                          /* weight */init[/* weight */1],
                                          /* cumulativeWeight */init[/* cumulativeWeight */2],
                                          /* descendants */init[/* descendants */3],
                                          /* parent : Some */[name]
                                        ]);
                            }), param[/* descendants */3]);
              }), towerInfos);
}

function walkUpGraph(someNodeName) {
  var _node = someNodeName;
  while(true) {
    var node = _node;
    var match = Hashtbl.find(graph, node)[/* parent */4];
    if (match) {
      _node = match[0];
      continue ;
      
    } else {
      return node;
    }
  };
}

function isListEven(param) {
  if (param) {
    var x = param[0];
    return List.fold_left((function (even, next) {
                  if (even) {
                    return Caml_obj.caml_equal(next, x);
                  } else {
                    return /* false */0;
                  }
                }), /* true */1, param[1]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/bjorn/projects/advent-of-code/src/Day7.re",
            65,
            17
          ]
        ];
  }
}

function findUnbalancedDisc(root) {
  var foundImbalance = [/* false */0];
  var findImbalance = function (nodeName) {
    var node = Hashtbl.find(graph, nodeName);
    if (List.length(node[/* descendants */3]) !== 0) {
      List.iter(findImbalance, node[/* descendants */3]);
      var descCumWeights = List.map((function (descName) {
              return Hashtbl.find(graph, descName)[/* cumulativeWeight */2];
            }), node[/* descendants */3]);
      if (!isListEven(descCumWeights) && !foundImbalance[0]) {
        console.log("Imbalance at " + nodeName);
        List.iter((function (node) {
                console.log(node[/* name */0], node[/* cumulativeWeight */2]);
                return /* () */0;
              }), List.map(findNode, node[/* descendants */3]));
        foundImbalance[0] = /* true */1;
        return /* () */0;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  };
  return findImbalance(root);
}

function addCumulativeWeights(root) {
  var calculateCumulativeWeight = function (nodeName) {
    var node = Hashtbl.find(graph, nodeName);
    var descendants = node[/* descendants */3];
    var cumulativeWeight = descendants ? node[/* weight */1] + List.fold_left((function (sum, descendant) {
              return sum + calculateCumulativeWeight(descendant) | 0;
            }), 0, descendants) | 0 : node[/* weight */1];
    replaceNode(/* record */[
          /* name */node[/* name */0],
          /* weight */node[/* weight */1],
          /* cumulativeWeight : Some */[cumulativeWeight],
          /* descendants */node[/* descendants */3],
          /* parent */node[/* parent */4]
        ]);
    return cumulativeWeight;
  };
  calculateCumulativeWeight(root);
  return /* () */0;
}

var towerInfos = List.map(decodeTowerInfo, Utils$AdventOfCode.linesOfString(Inputs$AdventOfCode.day7));

makeGraph(towerInfos);

var someNodeName = List.hd(towerInfos)[/* name */0];

var root = walkUpGraph(someNodeName);

addCumulativeWeights(root);

var part2 = findUnbalancedDisc(root);

exports.getParent            = getParent;
exports.decodeTowerInfo      = decodeTowerInfo;
exports.decodeTowerInfos     = decodeTowerInfos;
exports.graph                = graph;
exports.addNode              = addNode;
exports.replaceNode          = replaceNode;
exports.findNode             = findNode;
exports.makeGraph            = makeGraph;
exports.walkUpGraph          = walkUpGraph;
exports.isListEven           = isListEven;
exports.findUnbalancedDisc   = findUnbalancedDisc;
exports.addCumulativeWeights = addCumulativeWeights;
exports.part2                = part2;
/* graph Not a pure module */
