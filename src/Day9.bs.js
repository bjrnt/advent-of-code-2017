// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List               = require("bs-platform/lib/js/list.js");
var Pervasives         = require("bs-platform/lib/js/pervasives.js");
var Utils$AdventOfCode = require("./Utils.bs.js");

function parse(str) {
  var chars = Utils$AdventOfCode.charsOfString(str);
  var parseGroup = function (_chars, _depth, _score, garbageCount) {
    while(true) {
      var score = _score;
      var depth = _depth;
      var chars = _chars;
      var exit = 0;
      if (chars) {
        var match = chars[0];
        if (match !== 44) {
          if (match >= 123) {
            if (match >= 126) {
              exit = 1;
            } else {
              switch (match - 123 | 0) {
                case 0 : 
                    _depth = depth + 1 | 0;
                    _chars = chars[1];
                    continue ;
                    case 1 : 
                    exit = 1;
                    break;
                case 2 : 
                    var tl = chars[1];
                    if (tl) {
                      _score = score + depth | 0;
                      _depth = depth - 1 | 0;
                      _chars = tl;
                      continue ;
                      
                    } else {
                      return /* tuple */[
                              score + depth | 0,
                              garbageCount
                            ];
                    }
                    break;
                
              }
            }
          } else if (match !== 60) {
            exit = 1;
          } else {
            var _chars$1 = chars[1];
            var _ignoreNext = /* false */0;
            var depth$1 = depth;
            var score$1 = score;
            var _garbageCount = garbageCount;
            while(true) {
              var garbageCount$1 = _garbageCount;
              var ignoreNext = _ignoreNext;
              var chars$1 = _chars$1;
              if (ignoreNext) {
                _ignoreNext = /* false */0;
                _chars$1 = List.tl(chars$1);
                continue ;
                
              } else if (chars$1) {
                var match$1 = chars$1[0];
                if (match$1 !== 33) {
                  if (match$1 !== 62) {
                    _garbageCount = garbageCount$1 + 1 | 0;
                    _ignoreNext = /* false */0;
                    _chars$1 = chars$1[1];
                    continue ;
                    
                  } else {
                    return parseGroup(chars$1[1], depth$1, score$1, garbageCount$1);
                  }
                } else {
                  _ignoreNext = /* true */1;
                  _chars$1 = chars$1[1];
                  continue ;
                  
                }
              } else {
                return Pervasives.failwith("Failed on" + Utils$AdventOfCode.charsToString(chars$1));
              }
            };
          }
        } else {
          _chars = chars[1];
          continue ;
          
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return Pervasives.failwith("Failed on" + Utils$AdventOfCode.charsToString(chars));
      }
      
    };
  };
  return parseGroup(List.tl(chars), 1, 0, 0);
}

function test(str, expected, expectedGarbage) {
  var match = parse(str);
  var garbage = match[1];
  var score = match[0];
  if (score !== expected || garbage !== expectedGarbage) {
    console.log(str);
    console.log("Score: " + (Pervasives.string_of_int(score) + (" == " + Pervasives.string_of_int(expected))));
    console.log("Garbage: " + (Pervasives.string_of_int(garbage) + (" == " + Pervasives.string_of_int(expectedGarbage))));
    return /* () */0;
  } else {
    return 0;
  }
}

exports.parse = parse;
exports.test  = test;
/* No side effect */
