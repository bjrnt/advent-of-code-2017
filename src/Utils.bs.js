// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var $$Array     = require("bs-platform/lib/js/array.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var $$String    = require("bs-platform/lib/js/string.js");
var Pervasives  = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function linesOfString(str) {
  return $$Array.to_list(str.split("\n"));
}

function splitString(sep, str) {
  return $$Array.to_list(str.split(sep));
}

function wordsOfString(param) {
  return $$Array.to_list(param.split(" "));
}

function charsOfString(str) {
  var _i = str.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    var match = +(i < 0);
    if (match !== 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(str, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function charsToString(chars) {
  return $$String.concat("", List.map((function (param) {
                    return $$String.make(1, param);
                  }), chars));
}

function zip2(xs, ys) {
  return List.fold_left2((function (list, x, y) {
                return /* :: */[
                        /* tuple */[
                          x,
                          y
                        ],
                        list
                      ];
              }), /* [] */0, xs, ys);
}

function range(until) {
  var makeRange = function (_list, _next) {
    while(true) {
      var next = _next;
      var list = _list;
      var match = +(next > until);
      if (match !== 0) {
        return list;
      } else {
        _next = next + 1 | 0;
        _list = /* :: */[
          next,
          list
        ];
        continue ;
        
      }
    };
  };
  return List.rev(makeRange(/* [] */0, 0));
}

function isSome(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function take(n, xs) {
  var match = +(n === 0);
  if (match !== 0) {
    return /* [] */0;
  } else if (xs) {
    return /* :: */[
            xs[0],
            take(n - 1 | 0, xs[1])
          ];
  } else {
    return Pervasives.failwith("Cannot take from list");
  }
}

function skip(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n !== 0) {
      if (n !== 1) {
        _xs = List.tl(xs);
        _n = n - 1 | 0;
        continue ;
        
      } else {
        return List.tl(xs);
      }
    } else {
      return xs;
    }
  };
}

function expect(str, x) {
  if (x) {
    return x[0];
  } else {
    return Pervasives.failwith(str);
  }
}

function $great$great(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function remember(pred, reference, nextValue) {
  if (Curry._2(pred, nextValue, reference[0])) {
    reference[0] = nextValue;
  }
  return nextValue;
}

exports.linesOfString = linesOfString;
exports.splitString   = splitString;
exports.wordsOfString = wordsOfString;
exports.charsOfString = charsOfString;
exports.charsToString = charsToString;
exports.zip2          = zip2;
exports.range         = range;
exports.isSome        = isSome;
exports.take          = take;
exports.skip          = skip;
exports.expect        = expect;
exports.$great$great  = $great$great;
exports.remember      = remember;
/* No side effect */
